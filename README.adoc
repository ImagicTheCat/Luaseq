= Luaseq
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: left
:toclevels: 5

Luaseq is an asynchronous helper library built on coroutines. It can be used to perform asynchronous tasks in a "sequential" way.

== Install

See link:src[], link:rockspecs[] or https://luarocks.org/modules/imagicthecat-0a6b669a3a/luaseq[luarocks].

CAUTION: PUC Lua 5.1 is not supported (lack of xpcall arguments and yield accross pcall).

== Concept

=== Task

A task represents an asynchronous operation; it may be a standalone handle or an asynchronous function call wrapped as a coroutine.

Other operations can wait for the task completion, e.g. from multiple coroutines. This may be used to design complex asynchronous dependencies.

=== Mutex

A mutex (**Mut**ual **Ex**clusion) is useful even for cooperative VM threads (coroutines). While the fundamental operations are not executed in parallel, higher asynchronous operations semantically can.

WARNING: VM thread mutexes, as for OS thread mutexes, must be carefully used to avoid deadlocks (in this case, between coroutines).

== API

[WARNING]
====
To prevent coroutine resume errors from being silently handled, they are propagated to the caller (e.g. task completion or mutex unlocking) and will interrupt resuming of the other waiting coroutines. Instead of catching errors from the resuming side, it is probably better to catch them from the coroutines themselves, where it matters.

This is already handled by the `async()` API which propagates the errors to the task handle.
====

NOTE: Resume errors are recursively propagated using `debug.traceback`, which may result in multiple stack tracebacks.

WARNING: Task wait/completion and mutex lock/unlocking, as with callbacks, may transfer the execution to "third-party" code; thus the execution state must be carefully analyzed.

[source,lua]
----
-- Asynchronous operation.
--
-- No arguments: create a standalone task handle.
-- With arguments: create a task wrapping an asynchronous function call.
-- I.e. it executes the passed function as a coroutine, like a detached job.
--- f: function
--- ...: arguments
-- return task
Luaseq.async(f, ...)

-- Create a mutex.
-- mode: (optional) "reentrant"
-- return mutex
Luaseq.mutex(mode)

-- Task

-- Wait for task completion.
-- No arguments (sync): yield the current coroutine if the task is not done yet.
--- returns the task return values or propagates the task error.
-- With arguments (async):
--- callback(task): called when the task is done (completion or error)
task:wait(callback)

-- Complete task (subsequent calls will throw an error).
-- Waiting coroutines/callbacks are resumed in the same order of wait() calls.
--
-- ...: task return values
task:complete(...)
task(...)

-- Terminate task with an error (subsequent calls will throw an error).
-- Waiting coroutines/callbacks are resumed in the same order of wait() calls.
--
-- ...: arguments passed to standard error()
task:error(...)

-- Check if the task is done (completed or terminated with an error).
-- return boolean
task:done()

-- A task is a table where the array part is the list of waiting coroutines/callbacks.
-- When done, some fields are added:
task.r -- table of returned values, formatted like table.pack(...)
task.err -- truthy if the task terminated with an error
-- In that case, the returned values are arguments for the standard error function.

-- Mutex

-- Lock mutex.
mutex:lock()

-- Unlock mutex.
-- Waiting coroutines are resumed in the same order of lock() calls.
mutex:unlock()

-- Check if the mutex is locked.
-- return boolean
mutex:locked()

-- A mutex is a table where the array part is the list of locking coroutines,
-- the first being the active one followed by the waiting ones.
mutex.locks -- number of active thread locks
mutex.reentrant -- exist/true if reentrant
----

.Basic usage
====
If we have an asynchronous process, like fetching an URL:

[source,lua]
----
local Luaseq = require("Luaseq")
async = Luaseq.async

-- Create the async download function.
function download(url)
  local task = async() -- create task
  http_request(url, function(ok, content_or_error)
    if ok then task(content_or_error)
    else task:error(content_or_error) end
  end)
  return task:wait() -- wait for the returned values
end

-- Download 10 URLs sequentially.
local download_task = async(function()
  for i=1,10 do
    local content = download("http://foo.bar/"..i..".txt")
    print(content)
  end
end)
----
====

.Mutex
====
If we have an asynchronous process which saves data to a SQL database:

[source,lua]
----
local Luaseq = require("Luaseq")
async = Luaseq.async

local txn = Luaseq.mutex()

-- Save the state of something using a transaction.
-- query() could be asynchronous too.
function save(thing)
  txn:lock()
  query("START TRANSACTION")
  query("UPDATE ...")
  some_async_task()
  query("UPDATE ...")
  some_async_task()
  query("UPDATE ...")
  query("COMMIT")
  txn:unlock()
end
----

Now `save(thing)` can be called from parallel (not fundamentally) tasks without corrupting the transaction.
====
