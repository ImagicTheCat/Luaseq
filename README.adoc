= Luaseq
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: left
:toclevels: 5

Luaseq is an asynchronous helper library built on coroutines. It can be used to perform asynchronous tasks in a "sequential" way.

== Install

See link:src[], link:rockspecs[] or https://luarocks.org/modules/imagicthecat-0a6b669a3a/luaseq[luarocks].

== Concept

=== Task

A task can be created and then waited for completion from multiple coroutines. This can be used to design complex asynchronous dependencies.

=== Mutex

A mutex (**Mut**ual **Ex**clusion) is useful even for VM threads (coroutines). While the fundamental operations are not executed in parallel, higher asynchronous operations semantically can.

WARNING: VM thread mutexes, as for OS thread mutexes, must be carefully used to avoid deadlocks (in this case, between coroutines).

== API

WARNING: To prevent coroutine resume errors from being silently handled, they are propagated to the caller (e.g. task completion or mutex unlocking) and will interrupt resuming of the other waiting coroutines. Instead of catching errors from the caller, it is probably better to catch them from the coroutines themselves, where it matters.

NOTE: Coroutine resume errors are written on `stderr` prefixed by `async: ...`.

WARNING: Task wait/completion and mutex lock/unlocking, as with callbacks, may transfer the execution to "third-party" code; thus the execution state must be carefully analyzed.

[source,lua]
----
-- Async utility.
--
-- No arguments: create a task.
--- return task
--
-- With arguments: execute a function as a coroutine (directly resumed).
-- Note: this does nothing special, any coroutine can be used with the library.
--
--- f: function
--- ...: arguments
--- return created coroutine (thread)
Luaseq.async(f, ...)

-- Create a mutex.
-- mode: (optional) "reentrant"
-- return mutex
Luaseq.mutex(mode)

-- Task

-- Wait for task completion.
-- Will yield the current coroutine if the task is not completed.
--
-- return task return values
task:wait()

-- Complete task (subsequent calls will throw an error).
-- Waiting coroutines are resumed in the same order of wait() calls.
--
-- ...: task return values
task(...)

-- Check if the task is completed.
-- return boolean
task:completed()

-- A task is a table where the array part is the list of waiting coroutines.
-- When completed, two fields are added:
task.r -- list of return values
task.n -- number of return values

-- Mutex

-- Lock mutex.
mutex:lock()

-- Unlock mutex.
-- Waiting coroutines are resumed in the same order of lock() calls.
mutex:unlock()

-- Check if the mutex is locked.
-- return boolean
mutex:locked()

-- A mutex is a table where the array part is the list of locking coroutines,
-- the first being the active one followed by the waiting ones.
mutex.locks -- number of active thread locks
mutex.reentrant -- exist/true if reentrant
----

.Basic usage
====
If we have an asynchronous process, like fetching an URL:

[source,lua]
----
local Luaseq = require("Luaseq")
async = Luaseq.async

-- Create the async download function.
function download(url)
  local r = async() -- create task
  http_request(url, function(content) -- useless outer callback for the sake of clarity
    r(content) -- complete task, return content
  end)
  return r:wait() -- wait for the returned values
end

-- Download 10 URLs sequentially (need to be inside a coroutine).
async(function()
  for i=1,10 do
    local content = download("http://foo.bar/"..i..".txt")
    print(content)
  end
end)
----
====

.Mutex
====
If we have an asynchronous process which saves data to a SQL database:

[source,lua]
----
local Luaseq = require("Luaseq")
async = Luaseq.async

local txn = Luaseq.mutex()

-- Save the state of something using a transaction.
-- query() could be asynchronous too.
function save(thing)
  txn:lock()
  query("START TRANSACTION")
  query("UPDATE ...")
  some_async_task()
  query("UPDATE ...")
  some_async_task()
  query("UPDATE ...")
  query("COMMIT")
  txn:unlock()
end
----

Now `save(thing)` can be called from parallel (not fundamentally) tasks without corrupting the transaction.
====
